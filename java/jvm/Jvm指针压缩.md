基于以下事实

1. CPU 使用的虚拟地址是64位的, 访问内存时, 必须使用64位的指针访问内存对象
2. java对象是分配于具体的某个内存位置的, 对其访问必须使用64位地址
3. 对java对象内的引用字段进行访问时, 必须经过虚拟机这一层, 操作某个对象引用不管是getfield还是putfield, 都是由虚拟机来执行. 或者简单来说, 要改变java对象某个引用字段, 必须经过虚拟机的参与.

由于存一个对象引用和取一个对象引用必须经过**虚拟机**, 所以完全可以在虚拟机这一层做些手脚. 对于外部来说, putfield提供的对象地址是64位的, 经过虚拟机的转换, 映射到32位, 然后存入对象; getfield指定目标对象的64位地址和其内部引用字段的偏移, 取32位的数据, 然后反映射到64位内存地址. 对于外部来说, 只看见64位的对象放进去, 拿出来, 内部的转换是透明的.

# 什么是java对象的指针压缩？

1. jdk1.6 update14 开始，在 64bit 操作系统中，JVM 支持指针压缩
2. jvm 配置参数: UseCompressedOops，compressed--压缩、oop--对象指针
3. 启用指针压缩: `-XX:+UseCompressedOops`，禁止指针压缩: `-XX:-UseCompressedOops`

# 为什么要进行指针压缩？
1. 在 64 位平台的 HotSpot 中使用 32 位指针，内存使用会多出 1.5 倍左右，使用较大指针在主内存和缓存之间移动数据，占用较大宽带，同时 GC 也会承受较大压力
2. 为了减少 64 位平台下内存的消耗，启用指针压缩功能
3. 在 jvm 中，32 位地址表示 4G 个对象的指针，在 4G-32G 堆内存范围内，可以通过编码、解码方式进行优化，使得jvm可以支持更大的内存配置
4. 堆内存小于 4G 时，不需要启用指针压缩，jvm 会直接去除高32位地址，即使用低虚拟地址空间
5. 堆内存大于 32G 时，压缩指针会失效，会强制使用 64位(即8字节) 来对java对象寻址，这就会出现1的问题，所以堆内存不要大于32G为好

# 指针压缩的原理是什么？
1. 解释器解释字节码，植入压缩指令，进行编码、解码
2. 需要操作系统底层支持:**GC堆从虚拟地址0开始分配**

# 哪些信息会被压缩？
1. 对象的全局静态变量(即类属性)
2. 对象头信息:64位平台下，原生对象头大小为16字节，压缩后为12字节
3. 对象的引用类型:64位平台下，引用类型本身大小为8字节，压缩后为4字节
4. 对象数组类型:64位平台下，数组类型本身大小为24字节，压缩后16字节

# 哪些信息不会被压缩？
1. 指向非Heap的对象指针
2. 局部变量、传参、返回值、NULL指针
# 隔离级别

1. **READ UNCOMMITTED**（读未提交）

   在READ UNCOMMITTED级别，事务中的修改，即使没有提交，对其他事务也都是可见的。*事务可以读取未提交的数据*，这也被称为**脏读**（Dirty Read）。这个级别会导致很多问题，从性能上来说，READ UNCOMMITTED不会比其他的级别好太多，但却缺乏其他级别的很多好处，除非真的有非常必要的理由，在实际应用中一般很少使用。

2. **READ COMMITTED**（读已提交）

   大多数数据库系统的默认隔离级别都是READ COMMITTED（但MySQL不是）。READ COMMITTED满足前面提到的隔离性的简单定义：**一个事务开始时，只能“看见”已经提交的事务所做的修改**。换句话说，一个事务从开始直到提交之前，所做的任何修改对其他事务都是不可见的。这个级别有时候也叫做不可重复读（nonrepeatable read），因为两次执行同样的查询，可能会得到不一样的结果。

3. **REPEATABLE READ**（可重复读)

   REPEATABLE READ 解决了脏读的问题。该级别保证了在**同一个事务中多次读取同样记录的结果是一致的**。但是理论上，可重复读隔离级别还是无法解决另外一个幻读（Phantom Read）的问题。所谓**幻读**，*指的是当某个事务在读取某个范围内的记录时，另外一个事务又在该范围内插入了新的记录，当之前的事务再次读取该范围的记录时，会产生幻行（Phantom Row）*。InnoDB和XtraDB存储引擎通过多版本并发控制（MVCC，Multiversion Concurrency Control）解决了幻读的问题。本章稍后会做进一步的讨论。

   **可重复读是MySQL的默认事务隔离级别。**

4. **SERIALIZABLE**（串行化）

   SERIALIZABLE 是最高的隔离级别。它通过强制事务串行执行，避免了前面说的幻读的问题。简单来说，SERIALIZABLE会在读取的每一行数据上都加锁，所以可能导致大量的超时和锁争用的问题。实际应用中也很少用到这个隔离级别，只有在非常需要确保数据的一致性而且可以接受没有并发的情况下，才考虑采用该级别。

# MVCC

MySQL 的大多数事务型存储引擎实现的都不是简单的行级锁。基于提升并发性能的考虑，它们一般都同时实现了多版本并发控制（MVCC）。不仅是MySQL，包括 Oracle、PostgreSQL 等其他数据库系统也都实现了 MVCC，但各自的实现机制不尽相同，因为 MVCC 没有一个统一的实现标准。

可以认为 MVCC 是行级锁的一个变种，但是它**在很多情况下避免了加锁操作，因此开销更低**。虽然实现机制有所不同，但大都实现了**非阻塞的读**操作，写操作也只锁定必要的行。

MVCC 的实现，是通过**保存数据在某个时间点的快照来实现的**。也就是说，不管需要执行多长时间，每个事务看到的数据都是一致的。**根据事务开始的时间不同，每个事务对同一张表，同一时刻看到的数据可能是不一样的**。

**InnoDB 的 MVCC，是通过在每行记录后面保存两个隐藏的列来实现的。这两个列，一个保存了行的创建时间，一个保存行的过期时间（或删除时间）。当然存储的并不是实际的时间值，而是系统版本号（System Version Number）。每开始一个新的事务，系统版本号都会自动递增。事务开始时刻的系统版本号会作为事务的版本号，用来和查询到的每行记录的版本号进行比较**。下面看一下在 REPEATABLE READ 隔离级别下，MVCC 具体是如何操作的。

1. **SELECT**

   InnoDB会根据以下两个条件检查每行记录：

   ​		**InnoDB只查找版本早于当前事务版本的数据行（也就是，行的系统版本号小于或等于事务的系统版本号），这样可以确保事务读取的行，要么是在事务开始前已经存在的，要么是事务自身插入或者修改过的。
   行的删除版本要么未定义，要么大于当前事务版本号。这可以确保事务读取到的行，在事务开始之前未被删除。**只有符合上述两个条件的记录，才能返回作为查询结果。

2. **INSERT**

   InnoDB 为新插入的每一行保存当前系统版本号作为行版本号。

3. **DELETE**

   InnoDB 为删除的每一行保存当前系统版本号作为行删除标识。

4. **UPDATE**

   InnoDB 为插入一行新记录，保存当前系统版本号作为行版本号，同时保存当前系统版本号到原来的行作为行删除标识。

**保存这两个额外系统版本号，使大多数读操作都可以不用加锁。这样设计使得读数据操作很简单，性能很好，并且也能保证只会读取到符合标准的行。不足之处是每行记录都需要额外的存储空间，需要做更多的行检查工作，以及一些额外的维护工作。**

**MVCC 只在 *REPEATABLE READ* 和 *READ COMMITTED* 两个隔离级别下工作**。其他两个隔离级别都和 MVCC 不兼容，因为READ UNCOMMITTED 总是读取最新的数据行，而不是符合当前事务版本的数据行。而 SERIALIZABLE 则会对所有读取的行都加锁

![Mysql_MVCC.png](ref/Mysql_MVCC.png)
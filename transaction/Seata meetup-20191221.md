# Seata 的过去现在和未来

微服务拆分 与 数据库拆分 => 分布式事务

季敏 ：清明 @slievrly

ppt 

1221 Seata GA Meetup 讲师 PPT 下载链接：

https://space.dingtalk.com/s/gwHOAJQ82gLOFrVqBQPaACBkYTQ3NzMwNWU4NWM0MDFkYjdmOTk3YWUwMTY2ZWE4Yw 

密码: CHQ7

## 其他

设计原则：微内核 + 插件化

归并 update：合并多个 update 成一个

## 新特性

1. 动态配置，动态降级
2. 提供在线流程设计器，拖拽方式实现服务编排
3. add spring-boot-starter ：更轻量级
4. 支持 gRPC
5. 支持 Hessian
6. 支持协议压缩 gzip
7. 支持 where
8. exists 语法
9. 支持事务消息单条发送：traceId -> head
10. 支持配置的初始化脚本

## 优化

1. 批量插入 批量update 操作
2. saga 事务模式 nested
3. 支持 docker-compose，k8s 、helm
4. 配置简化
5. 一次性释放锁，减少 DB的 RPC 次数
6. AT 模式，分支事务的 report 可以关闭，性能50%

## bugfix

商业化产品 GTS（global transaction service） 、DTS

# Seata 的事务模型

## 1、AT 自动补偿模式(FMT模式)

### 1.1、AT 的根源

随着业务需求的扩展，单体应用需要向分布式、微服务方向拆分，分布式事务的需求应运而生

分布式事务需求：编程模型不变（业务侵入低、保证一致性），性能保证（开销小、吞吐高），可用性（高可用、降级可用）

### 1.2、AT的原理和机制

释放掉XA模式在数据源上的锁，分支事务提交完之后，直接commit本地事务并释放锁，即使这个时候，当前事务仍未结束，这个时候可以提升吞吐量。
那如何去回滚？在基于本地事务 LocalTransaction 特性，与业务数据一起写入 UndoLog，即回滚日志，保证只要有业务数据就一定有 UndoLog在。保证在全局事务结束前，事务是可以回滚的，另外UndoLog是持久化的，即使宕机也能保证数据不丢。

**TODO**

### 1.3、AT 的核心价值

在一致性 、易用性、性能三个方面都处理的比较好，全局锁可以提供一定的隔离性的支持。分布式事务在绝大部分情况下，都是会全部成功的，需要回滚的情况比较少，AT模式在第一阶段就把数据提交，可以省去第二阶段的操作，提升性能。一阶段提交，不阻塞;连接释放，保证整个系统的吞吐 ，但在回滚的时候，需要解析 UndoLog，会有一定的开销。

### 1.4、优缺点

不需要业务方去写 TCC 和 Saga 模式的几个方法，所以接入比较简单、业务侵入性比较小，然后相比较 XA 模式，虽然去除了对数据的全流程锁定，但是因为需要全局锁，在执行业务SQL的时候，也需要把前后镜像保存到 UndoLog里面去，所以性能会比较差。

AT 模式会全局锁数据，必须要全局释放之后，才会释放所有锁，导致吞吐下降厉害，所以需要一个更高效的方式

## 2、TCC 模式(也叫MT模式)
刚性事务&柔性事务 => 2PC => TCC 原理

### 2.1实现原理

try 节点基于 业务冻结字段 和 未达数据 来进行实现，在二阶段，根据是 commit 还是 rollback ，再进行冻结数据和未达数据累加到可用数字上。

### 优缺点

相比AT模式，不需要锁定业务资源，也不需要全局锁，所以性能更高，但是需要业务方实现 TCC 三个方法，业务侵入比较大，接入成本会比较高，在冲突出现概率较大的场景可以优先使用TCC。

**空回滚**：一阶段调用超时的时候，RM可能会不会收到try请求，直接收到回滚请求，所以RM在二阶段要允许空回滚。

**防悬挂**：网络拥堵的情况下，一阶段的 try 包还没有发送到 RM，TC 就发起回滚，导致 cancel 请求先于 try 到达 RM 端，所以要求业务方拒绝掉回滚后的 try 请求。

**幂等：** 因为二阶段操作失败会重试，所以要求TCC 三个方法都要支持幂等。

### 性能优化

支持**同库模式：**事务日志之前是 RM 发送给 TC 之后，TC 再存储到数据库，中间事务日志存在2次 RPC。现在采用事务日志直接保存到 RM 自己的数据库，减少了一次 RPC，另外也避免了 TC 数据库成为一个单点和性能瓶井，所以性能会有一些提升。

**二阶段异步化**：一阶段提交完之后，不等二阶段提交，直接返回，二阶段放到异步流程，性能提升50%。这个支持开关。

## 3、Saga 模式

### 理论基础 & 基于状态机引擎的 Saga 实现

### 使用场景 & 最佳实践

业务流程长、多，涉及到第三方公司（银行系统）或者遗留系统，无法完全提供TCC模式的三个接口的场景。

### 优缺点

一阶段提交本地事务，没有全局锁，性能比较高，参与者可以异步执行，吞吐高，补偿服务实现比较简单。缺点是 Saga 模式不保证隔离性。
通过 JSON 文件去定义整个流程，支持拖拽式的设计，方便开发和控制、服务编排。



需要业务方去实现正向流程和反向流程，使用灵活，性能高，但是因为没有数据锁，所以不保证隔离性，适用于**业务流程比较长且比较多**、历史遗留系统等场景。

## 4、XA 模式



# 高可用

# 高可扩展性

